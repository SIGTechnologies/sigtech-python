"""
Intended to be triggered manually to update rule classes
given the response from the `GET /validation/rules` endpoint.
"""

import logging
import shutil
import textwrap
from dataclasses import Field, dataclass, fields
from pathlib import Path
from typing import Any, Dict, List, Tuple

from jinja2 import Template

from sigtech.api.client.utils import camel_to_snake

logger = logging.getLogger(__name__)

RULES_DIR = Path(__file__).parents[1] / "sigtech/api/data/rules"
TRANSFORMS_DIR = Path(__file__).parents[1] / "sigtech/api/data/transforms"

TYPE_MAPPING = {
    "string": "str",
    "boolean": "bool",
    "number": "float",
    "integer": "int",
}


@dataclass
class BaseRuleValidator:
    """Base class used to validate rule inputs given constraints."""

    def __post_init__(self):
        self._validate_fields()

    def _validate_fields(self):
        for field in fields(self):
            if field.type in (int, float):
                self._validate_min_max(field)
            if field.type is list:
                self._validate_list(field)

    def _validate_list(self, field: Field):
        value = getattr(self, field.name)
        assert isinstance(value, list)
        min_items = field.metadata.get("minItems")
        assert isinstance(min_items, int)

        if len(value) < min_items:
            raise ValueError(f"{field.name} must have at least {min_items} items")

    def _validate_min_max(self, field: Field):
        value = getattr(self, field.name)
        min_value = field.metadata.get("min")
        max_value = field.metadata.get("max")

        if min_value is not None and value < min_value:
            raise ValueError(
                f"{field.name} must be greater than or equal to {min_value}"
            )

        if max_value is not None and value > max_value:
            raise ValueError(f"{field.name} must be less than or equal to {max_value}")


TEMPLATE = '''"""Code generated by {{ module_name }}"""

from dataclasses import dataclass, field
from sigtech.api.data.utils import BaseRule
from typing import List, Union

@dataclass
class {{ class_name }}(BaseRule):
    """
{{ docstrings }}
    """  # noqa: E501

    {% for field_name, field_data in fields.items() %}
    {{ field_name }}: {{ field_data.type }} = field({% if field_data.default %}default={{ field_data.default }}, {% endif %}metadata={{ field_data }})
    {% endfor %}
'''


def _get_docstrings(class_dict: dict) -> str:
    output = [class_dict.get("description", "") + "\n"]

    for prop_name, prop_data in class_dict.get("properties", {}).items():
        prop_type = prop_data.get("type", "object")
        prop_description = prop_data.get("description", "")

        additional_info = [
            f"{key}: {value}"
            for key, value in prop_data.items()
            if key
            not in [
                "title",
                "description",
                "type",
                "items",
                "order",
                "suffix",
            ]
        ]
        if prop_type == "array":
            item_type = prop_data.get("items", {}).get("type", "object")
            prop_type = f"array[{item_type}]"

        output.extend([f":param {prop_name} ({prop_type}): {prop_description}"])
        if additional_info:
            output.extend([f"    - {info}" for info in additional_info])
    if docs_url := class_dict.get("docs_url"):
        output.append(f"\ndocs: {docs_url}")

    docstrings = "\n".join(output).strip()

    return textwrap.indent(docstrings, "    ")


def generate_class_code_module(
    rule_metadata: dict, output_dir: Path
) -> Tuple[str, str]:
    # Modify dict properties
    properties: Dict[str, Any] = rule_metadata["properties"]

    # Update the "type" values in the dictionary
    for value in properties.values():
        if "type" in value and value["type"] in TYPE_MAPPING:
            value["type"] = TYPE_MAPPING[value["type"]]
        if "items" in value:
            value["type"] = f"List[{TYPE_MAPPING[value['items']['type']]}]"
        if "anyOf" in value:
            allowed_types = [TYPE_MAPPING[v["type"]] for v in value["anyOf"]]
            value["type"] = f"Union[{', '.join(allowed_types)}]"

    # Remove unnecessary keys from each dictionary
    for value in properties.values():
        value.pop("order", None)
        value.pop("title", None)
        value.pop("items", None)
        value.pop("enum", None)
        value.pop("suffix", None)

    # Separate items with 'default' key and without 'default' key
    items_with_default = {k: v for k, v in properties.items() if "default" in v}
    items_without_default = {k: v for k, v in properties.items() if "default" not in v}

    # For items with type 'str', add single quotes around the 'default' value
    for value in items_with_default.values():
        if value.get("type") == "str":
            value["default"] = f"'{value['default']}'"

    # Merge the dictionaries, putting items with 'default' at the end
    properties = {**items_without_default, **items_with_default}

    class_name = rule_metadata["type"]

    code = Template(TEMPLATE).render(
        module_name=__name__,
        class_name=class_name,
        docstrings=_get_docstrings(rule_metadata),
        fields=properties,
    )

    module_name = camel_to_snake(rule_metadata["type"])
    with open(output_dir / f"{module_name}.py", "w") as file:
        file.write(code)

    return module_name, class_name


def _generate_and_format_rule_classes(
    rules_metadata: List[Dict[str, Any]], output_dir: Path
):
    if output_dir.exists():
        shutil.rmtree(output_dir)

    output_dir.mkdir(parents=True, exist_ok=True)

    init_content = []
    __all__ = []
    for rule in rules_metadata:
        module_name, class_name = generate_class_code_module(
            rule_metadata=rule, output_dir=output_dir
        )
        init_content.append(f"from .{module_name} import {class_name}")
        __all__.append(class_name)

    init_content.append(f"__all__ = {__all__}")
    init_content.append("def __dir__(): return __all__")

    with open(output_dir / "__init__.py", "w") as f:
        f.write("\n".join(init_content))

    # Run autoflake, isort, black on all files
    subprocess.run(
        (
            [
                "python",
                "-m",
                "autoflake",
                "--in-place",
                "--remove-all-unused-imports",
                "--remove-unused-variables",
                "--recursive",
                output_dir,
            ]
        ),
        check=True,
    )
    subprocess.run(
        (
            [
                "python",
                "-m",
                "isort",
                "--profile",
                "black",
                output_dir,
            ]
        ),
        check=True,
    )
    subprocess.run(
        (
            [
                "python",
                "-m",
                "black",
                "--line-length",
                "88",
                "--experimental-string-processing",
                output_dir,
            ]
        ),
        check=True,
    )
    logger.info(f"Generated rule classes at {output_dir}")


if __name__ == "__main__":
    import subprocess

    import sigtech.api as sig

    logging.basicConfig(level=logging.INFO)

    sig.init()
    logger.info("Initialized sigtech.api client")

    rules_and_transforms = sig.data.Validation.get_rules_and_transforms()
    logger.info("Fetched rules and transforms metadata from DaVe API.")

    _generate_and_format_rule_classes(
        rules_metadata=rules_and_transforms.rules, output_dir=RULES_DIR
    )
    _generate_and_format_rule_classes(
        rules_metadata=rules_and_transforms.transforms, output_dir=TRANSFORMS_DIR
    )
